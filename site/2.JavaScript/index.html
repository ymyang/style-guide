<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>JavaScript代码规范 - 代码规范</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">代码规范</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li >
                        <a href="../1.Java/">Java代码规范</a>
                    </li>
                    <li class="active">
                        <a href="./">JavaScript代码规范</a>
                    </li>
                    <li >
                        <a href="../3.CSS/">CSS代码规范</a>
                    </li>
                    <li >
                        <a href="../4.HTML/">HTML代码规范</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../1.Java/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../3.CSS/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#javascript">JavaScript代码规范</a></li>
            <li><a href="#1">1. 类型</a></li>
        <li class="main "><a href="#2">2. 对象</a></li>
        <li class="main "><a href="#3">3. 数组</a></li>
        <li class="main "><a href="#4">4. 字符串</a></li>
        <li class="main "><a href="#5">5. 函数</a></li>
        <li class="main "><a href="#6">6. 属性</a></li>
        <li class="main "><a href="#7">7. 变量</a></li>
        <li class="main "><a href="#8">8. 提升</a></li>
        <li class="main "><a href="#9">9. 比较运算符 &amp; 等号</a></li>
        <li class="main "><a href="#10">10. 块</a></li>
        <li class="main "><a href="#11">11. 注释</a></li>
        <li class="main "><a href="#12">12. 空白</a></li>
        <li class="main "><a href="#13">13. 逗号</a></li>
        <li class="main "><a href="#14">14. 分号</a></li>
        <li class="main "><a href="#15">15. 类型转换</a></li>
        <li class="main "><a href="#16">16. 命名规则</a></li>
        <li class="main "><a href="#17">17. 存取器</a></li>
        <li class="main "><a href="#18">18. 构造函数</a></li>
        <li class="main "><a href="#19">19. 事件</a></li>
        <li class="main "><a href="#20">20. 模块</a></li>
        <li class="main "><a href="#21-jquery">21. jQuery</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="javascript">JavaScript代码规范</h1>
<p>v0.2</p>
<hr />
<h2 id="1">1. 类型</h2>
<ul>
<li>
<p><strong>原始值</strong>: 存取直接作用于它自身。</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
</li>
</ul>
<h1 id="_1"></h1>
<pre><code>var foo = 1;
var bar = foo;

bar = 9;

console.log(foo, bar); // =&gt; 1, 9
</code></pre>
<ul>
<li>
<p><strong>复杂类型</strong>: 存取时作用于它自身值的引用。</p>
<ul>
<li><code>object</code></li>
<li><code>array</code></li>
<li><code>function</code></li>
</ul>
</li>
</ul>
<h1 id="_2"></h1>
<pre><code>var foo = [1, 2];
var bar = foo;

bar[0] = 9;

console.log(foo[0], bar[0]); // =&gt; 9, 9
</code></pre>
<h2 id="2">2. 对象</h2>
<ul>
<li>使用直接量创建对象。</li>
</ul>
<h1 id="_3"></h1>
<pre><code>// bad
var item = new Object();

// good
var item = {};
</code></pre>
<ul>
<li>不要使用<a href="http://es5.github.io/#x7.6.1">保留字</a>作为变量名</li>
</ul>
<h1 id="_4"></h1>
<pre><code>// bad
var superman = {
  default: { clark: 'kent' },
  private: true
};

// good
var superman = {
  defaults: { clark: 'kent' },
  hidden: true
};
</code></pre>
<ul>
<li>使用同义词替换需要使用的保留字。</li>
</ul>
<h1 id="_5"></h1>
<pre><code>// bad
var superman = {
  class: 'alien'
};

// bad
var superman = {
  klass: 'alien'
};

// good
var superman = {
  type: 'alien'
};
</code></pre>
<h2 id="3">3. 数组</h2>
<ul>
<li>使用直接量创建数组。</li>
</ul>
<h1 id="_6"></h1>
<pre><code>// bad
var items = new Array();

// good
var items = [];
</code></pre>
<ul>
<li>向数组增加元素时使用 Array.push 来替代直接赋值。</li>
</ul>
<h1 id="_7"></h1>
<pre><code>var someStack = [];


// bad
someStack[someStack.length] = 'abracadabra';

// good
someStack.push('abracadabra');
</code></pre>
<ul>
<li>当你需要拷贝数组时，使用 Array.slice。</li>
</ul>
<h1 id="_8"></h1>
<pre><code>var len = items.length;
var itemsCopy = [];
var i;

// bad
for (i = 0; i &lt; len; i++) {
  itemsCopy[i] = items[i];
}

// good
itemsCopy = items.slice();
</code></pre>
<ul>
<li>使用 Array.slice 将类数组对象转换成数组。</li>
</ul>
<h1 id="_9"></h1>
<pre><code>function trigger() {
  var args = Array.prototype.slice.call(arguments);
  ...
}
</code></pre>
<h2 id="4">4. 字符串</h2>
<ul>
<li>使用单引号 <code>''</code> 包裹字符串。</li>
</ul>
<h1 id="_10"></h1>
<pre><code>// bad
var name = "Bob Parr";

// good
var name = 'Bob Parr';

// bad
var fullName = "Bob " + this.lastName;

// good
var fullName = 'Bob ' + this.lastName;
</code></pre>
<ul>
<li>超过 100 个字符的字符串应该使用连接符写成多行。</li>
</ul>
<h1 id="_11"></h1>
<pre><code>// bad
var errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';

// bad
var errorMessage = 'This is a super long error that was thrown because \
of Batman. When you stop to think about how Batman had anything to do \
with this, you would get nowhere \
fast.';

// good
var errorMessage = 'This is a super long error that was thrown because ' +
  'of Batman. When you stop to think about how Batman had anything to do ' +
  'with this, you would get nowhere fast.';
</code></pre>
<ul>
<li>程序化生成的字符串使用 Array.join 连接而不是使用连接符。</li>
</ul>
<h1 id="_12"></h1>
<pre><code>var items;
var messages;
var length;
var i;

messages = [{
  state: 'success',
  message: 'This one worked.'
}, {
  state: 'success',
  message: 'This one worked as well.'
}, {
  state: 'error',
  message: 'This one did not work.'
}];

length = messages.length;

// bad
function inbox(messages) {
  items = '&lt;ul&gt;';

  for (i = 0; i &lt; length; i++) {
    items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;';
  }

  return items + '&lt;/ul&gt;';
}

// good
function inbox(messages) {
  items = [];

  for (i = 0; i &lt; length; i++) {
    // use direct assignment in this case because we're micro-optimizing.
    items[i] = '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;';
  }

  return '&lt;ul&gt;' + items.join('') + '&lt;/ul&gt;';
}
</code></pre>
<h2 id="5">5. 函数</h2>
<ul>
<li>函数表达式：</li>
</ul>
<h1 id="_13"></h1>
<pre><code>// 匿名函数表达式
var anonymous = function() {
  return true;
};

// 命名函数表达式
var named = function named() {
  return true;
};

// 立即调用的函数表达式（IIFE）
(function () {
  console.log('Welcome to the Internet. Please follow me.');
}());
</code></pre>
<ul>
<li>永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。</li>
</ul>
<h1 id="_14"></h1>
<pre><code>// bad
if (currentUser) {
  function test() {
    console.log('Nope.');
  }
}

// good
var test;
if (currentUser) {
  test = function test() {
    console.log('Yup.');
  };
}
</code></pre>
<ul>
<li>永远不要把参数命名为 <code>arguments</code>。这将取代函数作用域内的 <code>arguments</code> 对象。</li>
</ul>
<h1 id="_15"></h1>
<pre><code>// bad
function nope(name, options, arguments) {
  // ...stuff...
}

// good
function yup(name, options, args) {
  // ...stuff...
}
</code></pre>
<h2 id="6">6. 属性</h2>
<ul>
<li>使用 <code>.</code> 来访问对象的属性。</li>
</ul>
<h1 id="_16"></h1>
<pre><code>var luke = {
  jedi: true,
  age: 28
};

// bad
var isJedi = luke['jedi'];

// good
var isJedi = luke.jedi;
</code></pre>
<ul>
<li>当通过变量访问属性时使用中括号 <code>[]</code>。</li>
</ul>
<h1 id="_17"></h1>
<pre><code>var luke = {
  jedi: true,
  age: 28
};

function getProp(prop) {
  return luke[prop];
}

var isJedi = getProp('jedi');
</code></pre>
<h2 id="7">7. 变量</h2>
<ul>
<li>总是使用 <code>var</code> 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。</li>
</ul>
<h1 id="_18"></h1>
<pre><code>// bad
superPower = new SuperPower();

// good
var superPower = new SuperPower();
</code></pre>
<ul>
<li>使用 <code>var</code> 声明每一个变量。
    这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 <code>;</code> 跟 <code>,</code>。</li>
</ul>
<h1 id="_19"></h1>
<pre><code>// bad
var items = getItems(),
    goSportsTeam = true,
    dragonball = 'z';

// bad
// （跟上面的代码比较一下，看看哪里错了）
var items = getItems(),
    goSportsTeam = true;
    dragonball = 'z';

// good
var items = getItems();
var goSportsTeam = true;
var dragonball = 'z';
</code></pre>
<ul>
<li>最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</li>
</ul>
<h1 id="_20"></h1>
<pre><code>// bad
var i, len, dragonball,
    items = getItems(),
    goSportsTeam = true;

// bad
var i;
var items = getItems();
var dragonball;
var goSportsTeam = true;
var len;

// good
var items = getItems();
var goSportsTeam = true;
var dragonball;
var length;
var i;
</code></pre>
<ul>
<li>在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</li>
</ul>
<h1 id="_21"></h1>
<pre><code>// bad
function () {
  test();
  console.log('doing stuff..');

  //..other stuff..

  var name = getName();

  if (name === 'test') {
    return false;
  }

  return name;
}

// good
function () {
  var name = getName();

  test();
  console.log('doing stuff..');

  //..other stuff..

  if (name === 'test') {
    return false;
  }

  return name;
}

// bad - 不必要的函数调用
function () {
  var name = getName();

  if (!arguments.length) {
    return false;
  }

  this.setFirstName(name);

  return true;
}

// good
function () {
  var name;

  if (!arguments.length) {
    return false;
  }

  name = getName();
  this.setFirstName(name);

  return true;
}
</code></pre>
<h2 id="8">8. 提升</h2>
<ul>
<li>变量声明会提升至作用域顶部，但赋值不会。</li>
</ul>
<h1 id="_22"></h1>
<pre><code>// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）
function example() {
  console.log(notDefined); // =&gt; throws a ReferenceError
}

// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。
// 注：变量赋值为 `true` 不会提升。
function example() {
  console.log(declaredButNotAssigned); // =&gt; undefined
  var declaredButNotAssigned = true;
}

// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：
function example() {
  var declaredButNotAssigned;
  console.log(declaredButNotAssigned); // =&gt; undefined
  declaredButNotAssigned = true;
}
</code></pre>
<ul>
<li>匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。</li>
</ul>
<h1 id="_23"></h1>
<pre><code>function example() {
  console.log(anonymous); // =&gt; undefined

  anonymous(); // =&gt; TypeError anonymous is not a function

  var anonymous = function () {
    console.log('anonymous function expression');
  };
}
</code></pre>
<ul>
<li>命名函数表达式会提升变量名，但不会提升函数名或函数体。</li>
</ul>
<h1 id="_24"></h1>
<pre><code>function example() {
  console.log(named); // =&gt; undefined

  named(); // =&gt; TypeError named is not a function

  superPower(); // =&gt; ReferenceError superPower is not defined

  var named = function superPower() {
    console.log('Flying');
  };
}

// 当函数名跟变量名一样时，表现也是如此。
function example() {
  console.log(named); // =&gt; undefined

  named(); // =&gt; TypeError named is not a function

  var named = function named() {
    console.log('named');
  }
}
</code></pre>
<ul>
<li>函数声明提升它们的名字和函数体。</li>
</ul>
<h1 id="_25"></h1>
<pre><code>function example() {
  superPower(); // =&gt; Flying

  function superPower() {
    console.log('Flying');
  }
}
</code></pre>
<h2 id="9">9. 比较运算符 &amp; 等号</h2>
<ul>
<li>优先使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code>.</li>
<li>
<p>条件表达式例如 <code>if</code> 语句通过抽象方法 <code>ToBoolean</code> 强制计算它们的表达式并且总是遵守下面的规则：</p>
<ul>
<li><strong>对象</strong> 被计算为 <strong>true</strong></li>
<li><strong>Undefined</strong> 被计算为 <strong>false</strong></li>
<li><strong>Null</strong> 被计算为 <strong>false</strong></li>
<li><strong>布尔值</strong> 被计算为 <strong>布尔的值</strong></li>
<li><strong>数字</strong> 如果是 <strong>+0、-0 或 NaN</strong> 被计算为 <strong>false</strong>，否则为 <strong>true</strong></li>
<li><strong>字符串</strong> 如果是空字符串 <code>''</code> 被计算为 <strong>false</strong>，否则为 <strong>true</strong></li>
</ul>
</li>
</ul>
<h1 id="_26"></h1>
<pre><code>if ([0]) {
  // true
  // 一个数组就是一个对象，对象被计算为 true
}
</code></pre>
<ul>
<li>使用快捷方式。</li>
</ul>
<h1 id="_27"></h1>
<pre><code>// bad
if (name !== '') {
  // ...stuff...
}

// good
if (name) {
  // ...stuff...
}

// bad
if (collection.length &gt; 0) {
  // ...stuff...
}

// good
if (collection.length) {
  // ...stuff...
}
</code></pre>
<h2 id="10">10. 块</h2>
<ul>
<li>使用大括号包裹所有的多行代码块。</li>
</ul>
<h1 id="_28"></h1>
<pre><code>// bad
if (test)
  return false;

// good
if (test) return false;

// good
if (test) {
  return false;
}

// bad
function () { return false; }

// good
function () {
  return false;
}
</code></pre>
<ul>
<li>如果通过 <code>if</code> 和 <code>else</code> 使用多行代码块，把 <code>else</code> 放在 <code>if</code> 代码块关闭括号的同一行。</li>
</ul>
<h1 id="_29"></h1>
<pre><code>// bad
if (test) {
  thing1();
  thing2();
}
else {
  thing3();
}

// good
if (test) {
  thing1();
  thing2();
} else {
  thing3();
}
</code></pre>
<h2 id="11">11. 注释</h2>
<ul>
<li>使用 <code>/** ... */</code> 作为多行注释。包含描述、指定所有参数和返回值的类型和值。</li>
</ul>
<h1 id="_30"></h1>
<pre><code>// bad
// make() returns a new element
// based on the passed in tag name
//
// @param {String} tag
// @return {Element} element
function make(tag) {

  // ...stuff...

  return element;
}

// good
/**
 * make() returns a new element
 * based on the passed in tag name
 *
 * @param {String} tag
 * @return {Element} element
 */
function make(tag) {

  // ...stuff...

  return element;
}
</code></pre>
<ul>
<li>使用 <code>//</code> 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。</li>
</ul>
<h1 id="_31"></h1>
<pre><code>// bad
var active = true;  // is current tab

// good
// is current tab
var active = true;

// bad
function getType() {
  console.log('fetching type...');
  // set the default type to 'no type'
  var type = this.type || 'no type';

  return type;
}

// good
function getType() {
  console.log('fetching type...');

  // set the default type to 'no type'
  var type = this.type || 'no type';

  return type;
}
</code></pre>
<ul>
<li>
<p>给注释增加 <code>FIXME</code> 或 <code>TODO</code> 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 <code>FIXME -- need to figure this out</code> 或者 <code>TODO -- need to implement</code>。</p>
</li>
<li>
<p>使用 <code>// FIXME:</code> 标注问题。</p>
</li>
</ul>
<h1 id="_32"></h1>
<pre><code>function Calculator() {

  // FIXME: shouldn't use a global here
  total = 0;

  return this;
}
</code></pre>
<ul>
<li>使用 <code>// TODO:</code> 标注问题的解决方式。</li>
</ul>
<h1 id="_33"></h1>
<pre><code>function Calculator() {

  // TODO: total should be configurable by an options param
  this.total = 0;

  return this;
}
</code></pre>
<h2 id="12">12. 空白</h2>
<ul>
<li>使用 2 个空格作为缩进。</li>
</ul>
<h1 id="_34"></h1>
<pre><code>// bad
function () {
∙∙∙∙var name;
}

// bad
function () {
∙var name;
}

// good
function () {
∙∙var name;
}
</code></pre>
<ul>
<li>在大括号前放一个空格。</li>
</ul>
<h1 id="_35"></h1>
<pre><code>// bad
function test(){
  console.log('test');
}

// good
function test() {
  console.log('test');
}

// bad
dog.set('attr',{
  age: '1 year',
  breed: 'Bernese Mountain Dog'
});

// good
dog.set('attr', {
  age: '1 year',
  breed: 'Bernese Mountain Dog'
});
</code></pre>
<ul>
<li>在控制语句（<code>if</code>、<code>while</code> 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。</li>
</ul>
<h1 id="_36"></h1>
<pre><code>// bad
if(isJedi) {
  fight ();
}

// good
if (isJedi) {
  fight();
}

// bad
function fight () {
  console.log ('Swooosh!');
}

// good
function fight() {
  console.log('Swooosh!');
}
</code></pre>
<ul>
<li>使用空格把运算符隔开。</li>
</ul>
<h1 id="_37"></h1>
<pre><code>// bad
var x=y+5;

// good
var x = y + 5;
</code></pre>
<ul>
<li>在使用长方法链时进行缩进。使用前面的点 <code>.</code> 强调这是方法调用而不是新语句。</li>
</ul>
<h1 id="_38"></h1>
<pre><code>// bad
$('#items').find('.selected').highlight().end().find('.open').updateCount();

// bad
$('#items').
  find('.selected').
    highlight().
    end().
  find('.open').
    updateCount();

// good
$('#items')
  .find('.selected')
    .highlight()
    .end()
  .find('.open')
    .updateCount();

// bad
var leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)
    .attr('width', (radius + margin) * 2).append('svg:g')
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')
    .call(tron.led);

// good
var leds = stage.selectAll('.led')
    .data(data)
  .enter().append('svg:svg')
    .classed('led', true)
    .attr('width', (radius + margin) * 2)
  .append('svg:g')
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')
    .call(tron.led);
</code></pre>
<ul>
<li>在块末和新语句前插入空行。</li>
</ul>
<h1 id="_39"></h1>
<pre><code>// bad
if (foo) {
  return bar;
}
return baz;

// good
if (foo) {
  return bar;
}

return baz;

// bad
var obj = {
  foo: function () {
  },
  bar: function () {
  }
};
return obj;

// good
var obj = {
  foo: function () {
  },

  bar: function () {
  }
};

return obj;
</code></pre>
<h2 id="13">13. 逗号</h2>
<ul>
<li>行首逗号: <strong>不需要</strong>。</li>
</ul>
<h1 id="_40"></h1>
<pre><code>// bad
var story = [
    once
  , upon
  , aTime
];

// good
var story = [
  once,
  upon,
  aTime
];

// bad
var hero = {
    firstName: 'Bob'
  , lastName: 'Parr'
  , heroName: 'Mr. Incredible'
  , superPower: 'strength'
};

// good
var hero = {
  firstName: 'Bob',
  lastName: 'Parr',
  heroName: 'Mr. Incredible',
  superPower: 'strength'
};
</code></pre>
<ul>
<li>额外的行末逗号：<strong>不需要</strong>。</li>
</ul>
<h1 id="_41"></h1>
<pre><code>// bad
var hero = {
  firstName: 'Kevin',
  lastName: 'Flynn',
};

var heroes = [
  'Batman',
  'Superman',
];

// good
var hero = {
  firstName: 'Kevin',
  lastName: 'Flynn'
};

var heroes = [
  'Batman',
  'Superman'
];
</code></pre>
<h2 id="14">14. 分号</h2>
<ul>
<li><strong>使用分号</strong></li>
</ul>
<h1 id="_42"></h1>
<pre><code>// bad
(function () {
  var name = 'Skywalker'
  return name
})()

// good
(function () {
  var name = 'Skywalker';
  return name;
})();

// good (防止函数在两个 IIFE 合并时被当成一个参数
;(function () {
  var name = 'Skywalker';
  return name;
})();
</code></pre>
<h2 id="15">15. 类型转换</h2>
<ul>
<li>在语句开始时执行类型转换。</li>
<li>字符串：</li>
</ul>
<h1 id="_43"></h1>
<pre><code>//  =&gt; this.reviewScore = 9;

// bad
var totalScore = this.reviewScore + '';

// good
var totalScore = '' + this.reviewScore;

// bad
var totalScore = '' + this.reviewScore + ' total score';

// good
var totalScore = this.reviewScore + ' total score';
</code></pre>
<ul>
<li>使用 <code>parseInt</code> 转换数字时总是带上类型转换的基数。</li>
</ul>
<h1 id="_44"></h1>
<pre><code>var inputValue = '4';

// bad
var val = new Number(inputValue);

// bad
var val = +inputValue;

// bad
var val = inputValue &gt;&gt; 0;

// bad
var val = parseInt(inputValue);

// good
var val = Number(inputValue);

// good
var val = parseInt(inputValue, 10);
</code></pre>
<ul>
<li>如果因为某些原因 <code>parseInt</code> 成为你所做的事的瓶颈而需要使用位操作解决<a href="http://jsperf.com/coercion-vs-casting/3">性能问题</a>时，留个注释说清楚原因和你的目的。</li>
</ul>
<h1 id="_45"></h1>
<pre><code>// good
/**
 * parseInt was the reason my code was slow.
 * Bitshifting the String to coerce it to a
 * Number made it a lot faster.
 */
var val = inputValue &gt;&gt; 0;
</code></pre>
<ul>
<li><strong>注：</strong> 小心使用位操作运算符。数字会被当成 <a href="http://es5.github.io/#x4.3.19">64 位值</a>，但是位操作运算符总是返回 32 位的整数（<a href="http://es5.github.io/#x11.7">source</a>）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。<a href="https://github.com/airbnb/javascript/issues/109">讨论</a>。最大的 32 位整数是 2,147,483,647：</li>
</ul>
<h1 id="_46"></h1>
<pre><code>2147483647 &gt;&gt; 0 //=&gt; 2147483647
2147483648 &gt;&gt; 0 //=&gt; -2147483648
2147483649 &gt;&gt; 0 //=&gt; -2147483647
</code></pre>
<ul>
<li>布尔:</li>
</ul>
<h1 id="_47"></h1>
<pre><code>var age = 0;

// bad
var hasAge = new Boolean(age);

// good
var hasAge = Boolean(age);

// good
var hasAge = !!age;
</code></pre>
<h2 id="16">16. 命名规则</h2>
<ul>
<li>避免单字符命名。命名应具备描述性。</li>
</ul>
<h1 id="_48"></h1>
<pre><code>// bad
function q() {
  // ...stuff...
}

// good
function query() {
  // ..stuff..
}
```
</code></pre>
<ul>
<li>使用驼峰式命名对象、函数和实例。</li>
</ul>
<h1 id="_49"></h1>
<pre><code>// bad
var OBJEcttsssss = {};
var this_is_my_object = {};
var o = {};
function c() {}

// good
var thisIsMyObject = {};
function thisIsMyFunction() {}
```
</code></pre>
<ul>
<li>使用帕斯卡式命名构造函数或类。</li>
</ul>
<h1 id="_50"></h1>
<pre><code>// bad
function user(options) {
  this.name = options.name;
}

var bad = new user({
  name: 'nope'
});

// good
function User(options) {
  this.name = options.name;
}

var good = new User({
  name: 'yup'
});
</code></pre>
<ul>
<li>不要使用下划线前/后缀。</li>
</ul>
<blockquote>
<p>为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。</p>
</blockquote>
<h1 id="_51"></h1>
<pre><code>// bad
this.__firstName__ = 'Panda';
this.firstName_ = 'Panda';
this._firstName = 'Panda';

// good
this.firstName = 'Panda';
</code></pre>
<ul>
<li>不要保存 <code>this</code> 的引用。使用 Function.bind。</li>
</ul>
<h1 id="_52"></h1>
<pre><code>// bad
function () {
  var self = this;
  return function () {
    console.log(self);
  };
}

// bad
function () {
  var that = this;
  return function () {
    console.log(that);
  };
}

// bad
function () {
  var _this = this;
  return function () {
    console.log(_this);
  };
}

// good
function () {
  return function () {
    console.log(this);
  }.bind(this);
}
</code></pre>
<ul>
<li>如果你的文件导出一个类，你的文件名应该与类名完全相同。</li>
</ul>
<h1 id="_53"></h1>
<pre><code>// file contents
class CheckBox {
  // ...
}
module.exports = CheckBox;

// in some other file
// bad
var CheckBox = require('./checkBox');

// bad
var CheckBox = require('./check_box');

// good
var CheckBox = require('./CheckBox');
</code></pre>
<h2 id="17">17. 存取器</h2>
<ul>
<li>属性的存取函数不是必须的。</li>
<li>如果你需要存取函数时使用 <code>getVal()</code> 和 <code>setVal('hello')</code>。</li>
</ul>
<h1 id="_54"></h1>
<pre><code>// bad
dragon.age();

// good
dragon.getAge();

// bad
dragon.age(25);

// good
dragon.setAge(25);
</code></pre>
<ul>
<li>如果属性是布尔值，使用 <code>isVal()</code> 或 <code>hasVal()</code>。</li>
</ul>
<h1 id="_55"></h1>
<pre><code>// bad
if (!dragon.age()) {
  return false;
}

// good
if (!dragon.hasAge()) {
  return false;
}
</code></pre>
<ul>
<li>创建 get() 和 set() 函数是可以的，但要保持一致。</li>
</ul>
<h1 id="_56"></h1>
<pre><code>function Jedi(options) {
  options || (options = {});
  var lightsaber = options.lightsaber || 'blue';
  this.set('lightsaber', lightsaber);
}

Jedi.prototype.set = function set(key, val) {
  this[key] = val;
};

Jedi.prototype.get = function get(key) {
  return this[key];
};
</code></pre>
<h2 id="18">18. 构造函数</h2>
<ul>
<li>给对象原型分配方法，而不是使用一个新对象覆盖原型。覆盖原型将导致继承出现问题：重设原型将覆盖原有原型！</li>
</ul>
<h1 id="_57"></h1>
<pre><code>function Jedi() {
  console.log('new jedi');
}

// bad
Jedi.prototype = {
  fight: function fight() {
    console.log('fighting');
  },

  block: function block() {
    console.log('blocking');
  }
};

// good
Jedi.prototype.fight = function fight() {
  console.log('fighting');
};

Jedi.prototype.block = function block() {
  console.log('blocking');
};
</code></pre>
<ul>
<li>方法可以返回 <code>this</code> 来实现方法链式使用。</li>
</ul>
<h1 id="_58"></h1>
<pre><code>// bad
Jedi.prototype.jump = function jump() {
  this.jumping = true;
  return true;
};

Jedi.prototype.setHeight = function setHeight(height) {
  this.height = height;
};

var luke = new Jedi();
luke.jump(); // =&gt; true
luke.setHeight(20); // =&gt; undefined

// good
Jedi.prototype.jump = function jump() {
  this.jumping = true;
  return this;
};

Jedi.prototype.setHeight = function setHeight(height) {
  this.height = height;
  return this;
};

var luke = new Jedi();

luke.jump()
  .setHeight(20);
</code></pre>
<ul>
<li>写一个自定义的 <code>toString()</code> 方法是可以的，但是确保它可以正常工作且不会产生副作用。</li>
</ul>
<h1 id="_59"></h1>
<pre><code>function Jedi(options) {
  options || (options = {});
  this.name = options.name || 'no name';
}

Jedi.prototype.getName = function getName() {
  return this.name;
};

Jedi.prototype.toString = function toString() {
  return 'Jedi - ' + this.getName();
};
</code></pre>
<h2 id="19">19. 事件</h2>
<ul>
<li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法：</li>
</ul>
<h1 id="_60"></h1>
<pre><code>// bad
$(this).trigger('listingUpdated', listing.id);

...

$(this).on('listingUpdated', function (e, listingId) {
  // do something with listingId
});


// good
$(this).trigger('listingUpdated', { listingId : listing.id });

...

$(this).on('listingUpdated', function (e, data) {
  // do something with data.listingId
});
</code></pre>
<h2 id="20">20. 模块</h2>
<ul>
<li>模块应该以 <code>!</code> 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误。<a href="https://github.com/airbnb/javascript/issues/44#issuecomment-13063933">详细说明</a></li>
<li>文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。</li>
<li>增加一个名为 <code>noConflict()</code> 的方法来设置导出的模块为前一个版本并返回它。</li>
<li>永远在模块顶部声明 <code>'use strict';</code>。</li>
</ul>
<h1 id="_61"></h1>
<pre><code>// fancyInput/fancyInput.js

!function (global) {
  'use strict';

  var previousFancyInput = global.FancyInput;

  function FancyInput(options) {
    this.options = options || {};
  }

  FancyInput.noConflict = function noConflict() {
    global.FancyInput = previousFancyInput;
    return FancyInput;
  };

  global.FancyInput = FancyInput;
}(this);
</code></pre>
<h2 id="21-jquery">21. jQuery</h2>
<ul>
<li>使用 <code>$</code> 作为存储 jQuery 对象的变量名前缀。</li>
</ul>
<h1 id="_62"></h1>
<pre><code>// bad
var sidebar = $('.sidebar');

// good
var $sidebar = $('.sidebar');
</code></pre>
<ul>
<li>缓存 jQuery 查询。</li>
</ul>
<h1 id="_63"></h1>
<pre><code>// bad
function setSidebar() {
  $('.sidebar').hide();

  // ...stuff...

  $('.sidebar').css({
    'background-color': 'pink'
  });
}

// good
function setSidebar() {
  var $sidebar = $('.sidebar');
  $sidebar.hide();

  // ...stuff...

  $sidebar.css({
    'background-color': 'pink'
  });
}
</code></pre>
<ul>
<li>对 DOM 查询使用层叠 <code>$('.sidebar ul')</code> 或 父元素 &gt; 子元素 <code>$('.sidebar &gt; ul')</code>。 </li>
<li>对有作用域的 jQuery 对象查询使用 <code>find</code>。</li>
</ul>
<h1 id="_64"></h1>
<pre><code>// bad
$('ul', '.sidebar').hide();

// bad
$('.sidebar').find('ul').hide();

// good
$('.sidebar ul').hide();

// good
$('.sidebar &gt; ul').hide();

// good
$sidebar.find('ul').hide();
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
